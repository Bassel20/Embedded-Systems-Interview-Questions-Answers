# C Language Interview Questions & Answers for Embedded SW Engineers #

## Questions ##
* [Q1: Explain C compilation process in detail](https://github.com/Bassel20/Embedded-Systems-Interview-Questions-Answers/blob/main/C%20Programming%20Questions.md#q1-explain-c-compilation-process-in-detail)
* [Q2: What is the difference between static, extern, volatile and register keywords?](https://github.com/Bassel20/Embedded-Systems-Interview-Questions-Answers/blob/main/C%20Programming%20Questions.md#q2-what-is-the-difference-between-static-extern-volatile-and-register-keywords)
* [Q3: How can we return multiple values from a function in C?](https://github.com/Bassel20/Embedded-Systems-Interview-Questions-Answers/blob/main/C%20Programming%20Questions.md#q3-how-can-we-return-multiple-values-from-a-function-in-C)
* [Q4: What do you know about #pragma?](https://github.com/Bassel20/Embedded-Systems-Interview-Questions-Answers/blob/main/C%20Programming%20Questions.md#q4-what-do-you-know-about-pragma)
* [Q5: Tell me about const keyword and its usage with pointers.](https://github.com/Bassel20/Embedded-Systems-Interview-Questions-Answers/blob/main/C%20Programming%20Questions.md#q5-tell-me-about-const-keyword-and-its-usage-with-pointers)
* [Q6: Tell me about dynamic memory allocation in C?](https://github.com/Bassel20/Embedded-Systems-Interview-Questions-Answers/blob/main/C%20Programming%20Questions.md#q6-tell-me-about-dynamic-memory-allocation-in-c)
* [Q7: How can you call a function before main()?](https://github.com/Bassel20/Embedded-Systems-Interview-Questions-Answers/blob/main/C%20Programming%20Questions.md#q7-how-can-you-call-a-function-before-main())



## Questions & Answers ##

### Q1: Explain C compilation process in detail ###

The C compilation process converts source code into object code or machine code. 
The compilation process can be divided into four steps:

**1.	Preprocessor**
 *	Macros expansion
 *	File inclusion
 *	Conditional Compilation
 *	replaces the macros with their respective values
 *	includes the necessary header files.

**2.	Compiler**
*	takes the preprocessed code and converts it into assembly code
*	converts the intermediate file (.i) into an Assembly file (.s)
*	analyzes the code to detect syntax errors, type errors, and other issues
*	Contains: 
    *	Tokenizer (Removes comments and spaces)
    *	Syntax analyzer (has all C language rules)
    *	Parser (.c -> .asm)
    *	Optimizer (least exec time and least mem consumption)
*	If there are any errors, the compilation process stops, and the errors are reported to the developer

**3.	Assembler**
*	Takes in the assembly code generated in the previous step and converts it into machine code
*	generates an object file that can be linked with other object files to create a complete program

**4.	Linker**
*	takes the machine code generated by the assembler and links it with other necessary libraries to create an executable file
*	resolves external references
*	provides the necessary information for the OS to load the executable file into memory

The final output of the compilation process is an executable file that can be run on the target system. This file contains the machine instructions generated by the assembler and the necessary libraries linked by the linker.

### Q2: What is the difference between static, extern, volatile and register keywords? ###

**Static** is used to create a variable that is allocated for the entire lifetime of the program. A static variable can be declared inside a function or outside it, and it retains its value between function calls. If declared inside a function, the variable has local scope, which means it can only be accessed within that function. If declared outside a function, the variable has global scope, which means it can be accessed from any function in the program.

**Extern** is used to declare a variable or function that is defined in another source file or module. When a variable or function is declared as extern, the compiler knows that it is not defined in the current file and looks for its definition in other source files or modules.

**Volatile** is used to tell the compiler that a variable's value may be changed several times by some external entity or hardware, and that the compiler should not optimize away reads or writes to that variable. It tells the compiler that the variable's value can change unexpectedly, and that the value should be re-read or re-written every time it is accessed. An optimized variable can be invisible to other threads and never reach the main memory.

**Register** is used to tell the compiler to store the variable in a register instead of memory. This can result in faster access to the variable because registers are faster than memory. However, the use of “register” is only a suggestion to the compiler, and it may choose to ignore the request if it cannot be satisfied due to the limited number of registers available.

### Q3: How can we return multiple values from a function in C? ###

In C or C++, we cannot return multiple values from a function directly. But, we can use these tricks to return more than one value from a function:

* call by reference: A function can modify the values of multiple variables by passing their memory addresses as pointers to the function.
* Struct: A function can return a structure that contains multiple values.

### Q4: What do you know about #pragma? ###

The #pragma in C is a directive that provides extra required details to the C compiler about how to process the source code. These extra details can be anything that was somehow not passed within the program or the code logic.\
**Examples:**\
#pragma startup &nbsp; &nbsp; // Before the execution of main(), the function specified in pragma is needed to run\
#pragma exit &nbsp; &nbsp; // Before the end of program, the function specified in pragma is needed to run\
#pragma warn &nbsp; &nbsp; // Used to hide the warning messages.

### Q5: Tell me about "const" keyword and its usage with pointers. ###

In C language, the const keyword is used to indicate that a variable or pointer is read-only, which means that its value cannot be modified after it has been initialized. This is a useful tool for creating read-only variables and pointers that cannot be modified accidentally.

**const int\* ptr;**\
pointer to int is initialized. the value of the integer being pointed to cannot be changed through **ptr**.

**int num = 5;**\
**const int\* ptr1 = \&num;**\
ptr1 is a pointer to a constant integer. It means that the integer value being pointed to by ptr1 cannot be modified using ptr1. However, you can modify the integer value through other non-constant pointers or directly by using the variable name itself.

**int num = 5;**\
**int\* const ptr2 = \&num;**\
ptr2 is a constant pointer to an integer. It means that the pointer itself cannot be changed to point to a different memory location, but you can modify the integer value being pointed to by ptr2.

### Q6: Tell me about dynamic memory allocation in C? ###

In C, dynamic memory allocation is done in the heap memory segment of the RAM and is achieved using the functions malloc, calloc, and realloc. These functions are defined in the “stdlib.h”.

**malloc:** used to allocate a block of memory of a specified size. The function takes in a single argument, which is the number of bytes of memory to allocate, and it returns a pointer to the first byte of the allocated block. The pointer it returns is of type void*, which is a generic pointer that can be implicitly converted to any other pointer type.  If allocation fails, the function returns NULL.\

**calloc:** similar to malloc, but it also initializes the allocated memory to zero. It takes two arguments: the number of elements to allocate and the size of each element. The function returns a pointer to the first byte of the allocated block. If the allocation fails, the function returns NULL.\

**realloc:** used to change the size of an allocated block of memory. It takes two arguments: a pointer to the memory block to be resized and the new size of the block. The function returns a pointer to the first byte of the resized block. If the allocation fails, the function returns NULL.\

**free:** used to deallocate memory that was previously allocated using the malloc. takes a single argument which is a pointer to the block of memory to be deallocated. after calling free(), the contents of the memory block become undefined, and should not be accessed.

After you allocate memory using one of these functions, you can access it using a pointer. Once you are done using the memory, you should free it using the **free()** function to avoid memory leaks.

### Q7: How can you call a function before main()? ###

In C, you can call a function before main() using either attribute constructor or #pragma. This can be useful if you need to perform some initialization before the main function is executed.\
by declaring the function with the **\_\_attribute\_\_((constructor))** this specifies that the function should be called automatically before the main() function is executed.\
**Example:**
```
#include <stdio.h>
void my_function(void) __attribute__((constructor));
void my_function(void) {
    printf("This function is called before main()\n");
}

int main() 
{
    printf("This is the main function\n");
    return 0;
}
```
you can also use the **#pragma** preprocessor directive to specify a function that should be executed before the main() function.\
**Example:**
```
#include <stdio.h>
#pragma startup my_startup_function
void my_startup_function(void) {
    printf("This function is executed before main()\n");
}

int main(void) {

    printf("This is the main function\n");
    return 0;
}
```
